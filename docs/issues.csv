ID,Title,Content,Acceptance Criteria,Review Requirements,State,Labels
P0-3,完善 .gitignore 忽略本地第三方源码/测试资产,"**背景：** 当前仓库用于开源发布，但本地为了调试会下载/复制大体量依赖与测试资产（如 `sumo-rl` 源码包、路网样例、压缩包等）。这些文件一旦被 git 追踪会导致仓库膨胀、提交困难，并阻塞 push。

**当前问题：**
- `sumo-rl-1.4.5/` 与 `sumo-rl-1.4.5.zip` 属于本地下载的第三方源码/压缩包，不应进入版本控制。
- `路网/` 为测试用路网资产（非 `examples/` 的开源示例），不应进入版本控制。
- `sumo-mcp.7z` 等压缩包为本地归档产物，不应进入版本控制。

**修复内容：**
1. 在 `.gitignore` 中新增规则，忽略：
   - `sumo-rl-*/`、`sumo-rl-*.zip`
   - `路网/`
   - `*.7z`（以及必要的其他本地归档扩展）
2. 确保规则不误伤 `src/`、`doc/`、`docs/`、`examples/` 等开源内容。

**影响范围：** 发布、协作、push 流程（仓库体积/干净度）","1. 执行 `git status --porcelain` 不再出现 `?? sumo-rl-*/`、`?? sumo-rl-*.zip`、`?? 路网/`、`?? *.7z` 等未跟踪项（这些文件仍保留在磁盘上，但被忽略）
2. 执行 `git check-ignore -v sumo-rl-1.4.5 sumo-rl-1.4.5.zip 路网 sumo-mcp.7z` 均能命中对应 ignore 规则
3. 规则生效后不影响代码检索（例如 `rg -n run_rl_training src/` 正常）","1. 忽略规则尽量精确（优先目录/特定前缀，不要用过宽的 `*`）
2. 不要把 `examples/` 下的开源示例产物误忽略（已有反向规则需保留）
3. 不修改现有已生效的 Python/IDE 通用 ignore 规则",已完成,已完成
P1-3,RL: 统一参数入口并兼容 scenario/路径两种调用,"**背景：** 目前用户侧存在多种调用方式与参数命名（`episodes` vs `num_episodes`、`out_dir` vs `output_dir`、以及把 `scenario` 误传给 `train_custom`）。导致 RL 训练经常在参数解析阶段失败或行为不确定。

**已知现象（用户实测）：**
- `Training failed: not enough values to unpack (expected 2, got 1)`
- `Training failed: Connection closed by SUMO`
- 历史错误：`Unexpected keyword argument 'num_episodes'` / `Unexpected keyword argument 'algorithm'` / `too many values to unpack (expected 2)`

**根因定位（基于 sumo-rl 1.4.5 源码）：**
- `sumo_rl.environment.env.SumoEnvironment`：
  - `reset()`：`single_agent=False` 返回 `dict[ts_id, obs]`；`single_agent=True` 返回 `(obs, info)`。
  - `step()`：`single_agent=False` 返回 `(obs_dict, rewards_dict, dones_dict, info_dict)`；`single_agent=True` 返回 5 元组 `(obs, reward, terminated, truncated, info)`（Gymnasium 风格）。
- 因此 MCP 层需要明确约束/兼容返回形态，并统一外部参数契约。

**修复内容：**
1. 统一 MCP 入参（`src/server.py::manage_rl_task`）：
   - 支持同义字段：`episodes|num_episodes`、`steps|steps_per_episode`、`out_dir|output_dir`。
   - 支持 `scenario|scenario_name`：当提供 `scenario(_name)` 时，忽略 `net_file/route_file`，从 `sumo_rl/nets/<scenario>` 自动定位 `.net.xml` 与 `.rou.xml`。
2. 对常用场景名做别名映射（例如 `single-intersection` → `2way-single-intersection`），并在错误时返回可用场景列表（`list_rl_scenarios()`）。
3. 调用 `run_rl_training()` 改为关键字参数，避免 positional 传参错位导致的兼容性问题。
4. `doc/API.md` 同步更新：明确 `train_custom` 支持 `scenario(_name)` 与参数同义字段（唯一真相源仍为 `src/server.py`）。

**影响范围：** `manage_rl_task` 与 `run_workflow(rl_train)` 的用户体验与兼容性","1. （单元测试/Mock）对 `src/server.py::manage_rl_task(train_custom)`：
   - 传入 `{ episodes: 3, steps: 100 }` 与 `{ num_episodes: 3, steps_per_episode: 100 }` 解析结果一致（可通过 patch `mcp_tools.rl.run_rl_training` 断言入参）
   - 传入 `{ scenario: 'single-intersection' }` 可解析到 sumo-rl 的内置场景目录（优先 `single-intersection`，若不存在则 fallback `2way-single-intersection`），并定位到真实存在的 `.net.xml/.rou.xml` 路径（只验证路径解析，不要求启动 SUMO）
2. （手动验证）在 Windows+SUMO 环境执行 MCP 调用：`manage_rl_task(train_custom, {scenario: '3x3grid', episodes: 1, steps: 100})` 能进入训练流程（不再出现参数级错误）","1. 参数兼容必须“显式、可预测”：同义字段冲突时要有确定优先级并在返回值中提示
2. 别名映射应集中管理（避免散落多个 if）
3. 文档更新必须与 `src/server.py` 对齐（避免再次出现“理念一致但实现不同”）",已完成,已完成
P1-4,RL: SUMO 连接中断/解包异常的诊断与稳健性,"**背景：** 用户实测出现 `Connection closed by SUMO` 与 `not enough values to unpack`。在 TraCI 场景下，这类报错常见于 SUMO 启动参数错误、net/route 不匹配、或 SUMO 进程提前退出导致的协议读写异常。

**修复内容：**
1. `src/mcp_tools/rl.py::run_rl_training` 增强对返回形态的兼容：
   - `reset()` 若返回 `(obs, info)`，应自动取 `obs` 并继续（避免误判/异常）。
   - `step()` 兼容 4 元组与 5 元组返回（Gymnasium terminated/truncated 风格），并统一为可终止条件（防止死循环导致 SUMO 先退出再触发 TraCI 错误）。
2. 增加“最大步数”安全阈值：即使 `dones` 缺少 `__all__` 也能在预期步数内退出，避免无限循环。
3. 自动落地 SUMO 错误日志：为 `SumoEnvironment(additional_sumo_cmd=...)` 注入 `--error-log <out_dir>/sumo_error.log`（必要时追加 `--log`），当训练失败时返回日志末尾 N 行作为诊断信息。
4. 返回的错误消息补齐诊断上下文：`SUMO_HOME`、sumo binary 定位结果、使用的 net/route 路径、error-log 路径。

**影响范围：** 自定义训练与内置场景训练的可诊断性与稳定性","1. （单元测试/Mock）构造一个假的 env：
   - `reset()` 返回 `(obs, info)`；`step()` 返回 5 元组；验证 `run_rl_training()` 不抛异常并能正常收敛退出
2. （单元测试/Mock）模拟 `step()` 返回的 `dones` 不包含 `__all__`，验证“最大步数阈值”能终止循环
3. （手动验证）在 Windows+SUMO 环境复现原错误场景时，返回值中必须包含 `sumo_error.log` 的路径与末尾日志片段，便于定位 SUMO 退出原因","1. 不要静默吞错：若捕获异常，应尽量保留错误类型信息与关键上下文
2. 日志截取应限制长度（例如最后 80 行），避免 MCP 响应过大
3. 不要把用户主目录等敏感信息原样打印（路径可保留，但注意不要输出环境中无关机密）",已完成,已完成
P3-2,路网生成: Spider 参数映射无效（生成结果仍为 Grid）,"**现象（用户实测）：**
- 调用 `manage_network(action=generate, params={spider: true, arms: 8})` 生成了文件，但网络类型仍为 Grid（文件头部 `<grid_network>`）。

**根因：**
- `src/server.py::manage_network(generate)` 只透传 `grid/grid_number`，未处理 `spider` 相关参数。
- `src/mcp_tools/network.py::netgenerate()` 仅实现 `--grid` 参数拼装，缺少 `--spider` 与其专属参数映射。

**修复内容：**
1. 为 `manage_network(generate)` 增加网络类型选择（建议新增 `type` 或以 `spider=true` 触发）：
   - 当 `spider=true` 时忽略 `grid/grid_number`，并传递 spider 参数（如 `arms` / `ring_radius` / `radial_distance` 等）。
2. `netgenerate()` 扩展参数拼装：正确生成 spider 网络的命令行参数。
3. `doc/API.md` 更新 `manage_network/generate` 的参数说明：明确 Grid/Spider 的互斥与默认值。

**影响范围：** `manage_network(generate)` 功能完整性（路网类型覆盖）","1. （单元测试/Mock）patch `subprocess.run`，当 `spider=true` 时断言命令行包含 `--spider` 且不包含 `--grid`
2. （手动验证）实际运行生成：输出 net 文件头部包含 spider 网络标识（不再是 `<grid_network>`）
3. （回归）`grid=true` 逻辑保持不变","1. 参数互斥逻辑必须清晰（避免 grid/spider 同时生效）
2. spider 参数需有合理默认值与类型校验（如 arms 为正整数）
3. 命令行参数名需与 SUMO `netgenerate --help` 对齐（避免拼错导致 silent fallback）",已完成,已完成
P0-1,修复 pyproject.toml 打包配置,"**文件位置：** `pyproject.toml`

**当前问题：**
- 缺少 `[tool.hatch.build.targets.wheel]` 配置
- 执行 `pip install -e .` 报错：`ValueError: Unable to determine which files to ship inside the wheel`
- 项目使用 `src/` 布局但 hatchling 无法识别

**修复内容：**
在 `pyproject.toml` 文件末尾添加：
```toml
[tool.hatch.build.targets.wheel]
packages = [""src""]
```

**影响范围：** 项目打包和安装流程","1. 在干净虚拟环境执行 `python -m venv test_env && source test_env/bin/activate && pip install -e .` 成功且无错误
2. 执行 `python -c ""from server import server; print('OK')"" ` 输出 `OK`
3. 执行 `pip install build && python -m build` 成功生成 `dist/*.whl` 文件
4. 执行 `pip install dist/*.whl` 可在新环境中安装
5. wheel 文件包含 `src/` 目录下所有 Python 模块（通过 `unzip -l dist/*.whl` 验证）","1. 验证 `packages = [""src""]` 配置正确（不是 `packages = [""sumo_mcp""]`）
2. 确认不影响现有 dev dependencies 和 tool.mypy 配置
3. 验证 build 系统仍为 hatchling（不要改成 setuptools）",已完成,已完成
P0-2,实现 Windows 标准安装路径自动检测,"**文件位置：** `src/utils/sumo.py:43-67`（`find_sumo_home` 函数）

**当前问题：**
- 仅硬编码 Linux 路径 `/usr/share/sumo`
- Windows 用户即使安装 SUMO 到标准位置，不设置 SUMO_HOME 也会失败
- 未检测 Windows Registry 或常见安装目录

**修复内容：**
1. 在 `find_sumo_home()` 中添加 Windows 平台检测（`sys.platform == 'win32'`）
2. 检测常见 Windows 路径：
   - `C:/Program Files/Eclipse/sumo`
   - `C:/Program Files (x86)/Eclipse/sumo`
   - `D:/sumo`
   - `C:/sumo`
3. 可选：添加 Windows Registry 读取（`HKLM\SOFTWARE\Eclipse\SUMO\InstallPath`）
4. 添加 macOS Homebrew 支持（`/usr/local/Cellar/sumo/*/share/sumo`）
5. 修正 Linux 路径逻辑（当前返回 `/usr/share/sumo`，应返回父目录）

**影响范围：** 所有依赖 SUMO_HOME 检测的功能","1. 编写单元测试 `tests/test_utils_sumo.py::test_find_sumo_home_windows`，mock `sys.platform='win32'` 和 `Path.exists()`，验证返回 `C:/Program Files/Eclipse/sumo`
2. 编写单元测试 `test_find_sumo_home_macos`，验证 Homebrew 路径检测
3. 在实际 Windows 机器（SUMO 安装在 `C:\Program Files\Eclipse\sumo`，不设置 SUMO_HOME）运行 `python -c ""from utils.sumo import find_sumo_home; assert find_sumo_home() is not None""`
4. 执行 MCP 工具 `get_sumo_info`，验证能正确返回 SUMO 版本和路径
5. 确保 Linux 现有功能无回归（在 Linux 环境测试或 mock）","1. 确保 Windows 路径使用正斜杠 `/` 或 `Path` 对象（避免转义问题）
2. Registry 读取必须有 try-except 包裹（避免 winreg 不可用）
3. 验证 macOS 的 glob 模式正确（多版本共存场景）
4. 确保函数返回值类型一致（`Optional[str]`）
5. 添加日志输出便于调试（使用 `logging.debug`）",已完成,已完成
P1-1,修复 Windows 跨驱动器路径导致配置不可移植,"**文件位置：** `src/workflows/signal_opt.py`（`signal_opt_workflow` 和 `_as_cfg_path` 函数）

**当前问题：**
- 当 `net_file`/`route_file` 与 `output_dir` 在不同 Windows 驱动器时，`os.path.relpath()` 抛 `ValueError`
- 代码 fallback 到绝对路径，生成的 `.sumocfg` 包含 `D:\...` 形式的路径
- 配置文件无法在其他机器或目录使用

**修复内容（方案 A - 推荐）：**
1. 在 `signal_opt_workflow()` 开始处，将所有输入文件复制到 `output_dir`：
   ```python
   local_net_file = os.path.join(output_dir, os.path.basename(net_file))
   local_route_file = os.path.join(output_dir, os.path.basename(route_file))
   if os.path.abspath(net_file) != os.path.abspath(local_net_file):
       shutil.copy2(net_file, local_net_file)
   # Use local files afterwards
   ```
2. 修改 `_as_cfg_path()` 函数：
   - 移除 `try-except ValueError` 的绝对路径 fallback
   - 如果无法生成相对路径，使用 `basename` 并发出 `warnings.warn()`
3. 统一处理逻辑：`net_file`、`route_file`、`fcd_file` 使用相同规则（移除 line 102 的特殊处理）

**影响范围：** 信号优化工作流生成的所有 `.sumocfg` 文件","1. 编写单元测试 `tests/test_workflows_signal_opt.py::test_cross_drive_paths`（可在 Windows 运行或 mock `os.path.relpath` 抛 ValueError）
2. 验证生成的 `.sumocfg` 文件所有路径均为相对路径（通过正则 `r'[A-Z]:\\'` 匹配，应为空）
3. 在实际 Windows 跨驱动器场景测试：
   - `net_file='C:/test/net.xml'`，`output_dir='D:/output'`
   - 验证 `D:/output/` 下生成了 `net.xml` 副本
   - 验证 `.sumocfg` 中 `<net-file value=""net.xml""/>`（相对路径）
4. 将生成的 `output_dir` 移动到其他位置，执行 `sumo -c xxx.sumocfg`，验证能正常运行
5. 在 Linux 环境测试，确保无回归","1. 确认使用 `shutil.copy2()` 保留文件元数据
2. 验证不会重复复制文件（已存在且内容相同则跳过）
3. 检查 `_as_cfg_path()` 的 warning 消息清晰
4. 考虑大文件复制的性能影响（必要时添加进度提示）
5. 更新 `signal_opt_workflow` 的 docstring 说明文件会被复制",已完成,已完成
P1-2,重构 find_sumo_binary 返回值为 Optional 类型,"**文件位置：**
- `src/utils/sumo.py:9-29`（`find_sumo_binary` 函数定义）
- `src/mcp_tools/simulation.py:20-25`（调用处 1）
- `src/server.py:243`（调用处 2）
- 其他潜在调用处（需全局搜索）

**当前问题：**
- 找不到二进制时返回原始名称（如 `""sumo""`）而非 `None`
- 调用者必须用字符串比较 `if sumo_binary == ""sumo""` 判断失败
- 设计脆弱：调用 `find_sumo_binary(""sumo-gui"")` 时判断逻辑失效

**修复内容：**
1. 修改 `find_sumo_binary()` 签名和实现：
   ```python
   def find_sumo_binary(name: str) -> Optional[str]:
       # ... 检测逻辑 ...
       return which  # 返回 None 而非 name
   ```
2. 更新所有调用处的判断逻辑：
   ```python
   sumo_binary = find_sumo_binary(""sumo"")
   if not sumo_binary:  # 替代 if sumo_binary == ""sumo""
       return ""Error: ...""
   ```
3. 添加类型注解 `from typing import Optional`
4. 更新函数 docstring 说明返回值

**影响范围：** 所有 SUMO 二进制检测相关功能","1. 执行 `mypy src/` 验证类型注解正确，无类型错误
2. 全局搜索 `find_sumo_binary` 的所有调用（`grep -rn 'find_sumo_binary' src/`），确认所有调用处已更新
3. 编写单元测试 `test_find_sumo_binary_not_found`，mock `sumolib.checkBinary` 和 `shutil.which` 均失败，验证返回 `None`
4. 编写单元测试 `test_find_sumo_binary_found`，验证返回绝对路径
5. 在无 SUMO 环境运行 `run_simple_simulation()`，验证错误消息正确显示","1. 确认返回类型注解为 `Optional[str]`（不是 `Union[str, None]`）
2. 验证 `sumolib.checkBinary` 返回非路径字符串时也返回 `None`
3. 检查所有 `if sumo_binary == ` 的字符串比较都已移除
4. 确保向后兼容：如果有外部代码调用此函数，需在 CHANGELOG 注明 breaking change",已完成,已完成
P2-1,细化异常捕获范围避免隐藏错误,"**文件位置：** `src/utils/sumo.py:20-23`（`find_sumo_binary` 函数）

**当前问题：**
- 使用裸 `except Exception:` 捕获所有异常
- `sumolib.checkBinary()` 可能抛出多种异常（`SystemExit`、`OSError`、`ImportError`）
- 宽泛捕获会隐藏编程错误，用户无法得知真实问题

**修复内容：**
1. 将 `except Exception:` 改为具体异常类型：
   ```python
   try:
       resolved = sumolib.checkBinary(name)
       # ...
   except (SystemExit, OSError, FileNotFoundError) as e:
       import logging
       logging.debug(f""sumolib.checkBinary failed for {name}: {e}"")
       pass  # Fall through to PATH check
   ```
2. 添加 logging 支持（如果项目未配置 logging，添加基础配置）
3. 考虑在调试模式下重新抛出异常

**影响范围：** SUMO 二进制检测的健壮性","1. 编写单元测试 mock `sumolib.checkBinary` 抛出 `SystemExit`，验证正常 fallback
2. 编写单元测试 mock 抛出 `OSError`，验证正常 fallback
3. 编写单元测试 mock 抛出 `AttributeError`（编程错误），验证异常不被捕获（测试应失败）
4. 在实际 SUMO 损坏环境测试，验证 debug 日志有输出
5. 执行 `pytest tests/ -v` 确保所有测试通过","1. 确认 logging.debug 不会在生产环境打印到 stdout（避免污染 MCP 输出）
2. 验证异常类型列表完整（检查 sumolib 源码或实际测试）
3. 考虑是否需要 `except ImportError`（sumolib 未安装场景）
4. 确保不改变函数行为（仅改进错误处理）",已完成,已完成
P2-2,改进错误消息增加诊断信息,"**文件位置：**
- `src/mcp_tools/simulation.py:21-25`
- `src/mcp_tools/route.py:14-19`
- `src/mcp_tools/network.py:64-69`
- `src/mcp_tools/signal.py:12-17`
- 其他返回错误消息的位置

**当前问题：**
- 错误消息过于简单：`""Error finding sumo binary. Please ensure SUMO is installed...""`
- 用户不知道是 PATH 检测失败还是 SUMO_HOME 检测失败
- 无法自行诊断问题

**修复内容：**
1. 在 `simulation.py` 的错误消息中添加诊断信息：
   ```python
   if not sumo_binary:
       import os, shutil
       return (
           f""Error: Could not locate SUMO executable.\\n""
           f""Diagnostics:\\n""
           f""  - SUMO_HOME: {os.environ.get('SUMO_HOME', 'Not Set')}\\n""
           f""  - PATH search: {shutil.which('sumo') or 'Not Found'}\\n""
           f""  - sumolib check: Failed\\n""
           f""\\nPlease:\\n""
           f""  1. Install SUMO from https://sumo.dlr.de/\\n""
           f""  2. Set SUMO_HOME environment variable, OR\\n""
           f""  3. Add SUMO bin directory to PATH\\n""
       )
   ```
2. 对 tools 脚本（randomTrips、osmGet 等）的错误消息添加 `find_sumo_home()` 的实际返回值
3. 统一错误消息格式（建议使用三层结构：Error / Diagnostics / Solution）

**影响范围：** 所有用户面向的错误消息","1. 手动测试：在无 SUMO 环境执行 `run_simple_simulation()`，验证错误消息包含 `SUMO_HOME: Not Set` 和 `PATH search: Not Found`
2. 手动测试：设置错误的 SUMO_HOME，验证错误消息显示错误路径
3. 对每个修改的文件，编写单元测试验证错误消息格式正确
4. 确保错误消息在 MCP JSON-RPC 响应中正确显示（不被截断）
5. 代码审查：检查所有错误消息是否友好且可操作","1. 验证错误消息不包含敏感信息（如完整文件路径可能泄露用户名）
2. 确保 shutil.which() 调用不会阻塞（在某些网络文件系统可能慢）
3. 考虑国际化（i18n）需求（当前版本可暂时使用英文）
4. 验证多行错误消息在 CLI 和 IDE 集成中显示正常
5. 检查错误消息长度（避免过长影响阅读）",已完成,已完成
P2-3,完善 README 和启动脚本的平台特定说明,"**文件位置：**
- `README.md`（安装和配置章节）
- `start_server.bat`（Windows 启动脚本）
- `start_server.sh`（Linux/macOS 启动脚本）
- `start_server.ps1`（PowerShell 启动脚本）
- `mcp_config_examples.json`（配置示例）

**当前问题：**
- 假设用户已知如何设置 SUMO_HOME
- 未提供 Windows/macOS/Linux 的不同安装指导
- 未说明""使用 tools 脚本时必须设置 SUMO_HOME，仅使用 binary 时可选""

**修复内容：**
1. 在 `README.md` 添加 ""Installation & Setup"" 章节，包含：
   - Windows 安装步骤（官方安装包 + 设置环境变量）
   - Linux 安装步骤（apt/yum 包管理器）
   - macOS 安装步骤（Homebrew）
   - 验证安装的命令
2. 添加 ""Important Notes"" 说明 SUMO_HOME 的使用场景
3. 更新 `mcp_config_examples.json`，添加注释说明环境变量设置
4. 在启动脚本中添加环境检查：
   ```bash
   if ! command -v sumo &> /dev/null && [ -z ""$SUMO_HOME"" ]; then
       echo ""Error: SUMO not found. Please install SUMO or set SUMO_HOME.""
       exit 1
   fi
   ```

**影响范围：** 新用户的首次安装体验","1. 按照 README 中 Windows 章节的步骤，在全新 Windows 机器上安装 SUMO 和 sumo-mcp，验证能成功运行
2. 按照 README 中 Linux 章节的步骤，在 Ubuntu 虚拟机验证
3. 按照 README 中 macOS 章节的步骤验证（或请 macOS 用户测试）
4. 执行修改后的启动脚本，在无 SUMO 环境验证错误消息正确显示
5. 检查所有文档链接有效（如 https://sumo.dlr.de/）","1. 确保文档中的命令可复制粘贴直接运行（避免特殊字符）
2. 验证 Windows 路径使用反斜杠或提示用户转换
3. 检查 Homebrew 安装命令是否为最新（`brew install sumo` 或 `brew install eclipse-sumo`）
4. 确保启动脚本的环境检查不影响 Docker 等容器化部署
5. 文档中添加 ""Troubleshooting"" 章节（常见问题）",已完成,已完成
P3-1,修复 Windows 平台测试兼容性问题,"**文件位置：** `tests/test_server_jsonrpc_smoke_without_sumo_home.py`（`_read_json_line` 函数）

**当前问题：**
- 测试使用 `selectors.select()` 处理进程 I/O
- Windows 的 `select()` 不支持文件描述符（仅支持 socket）
- 导致测试在 Windows 上失败：`OSError: [WinError 10038]`

**修复内容：**
1. 修改 `_read_json_line()` 函数，添加平台检测：
   ```python
   import sys
   if sys.platform == 'win32':
       # Use threading for Windows
       import threading, queue
       result_queue = queue.Queue()
       def reader():
           result_queue.put(process.stdout.readline())
       thread = threading.Thread(target=reader, daemon=True)
       thread.start()
       line = result_queue.get(timeout=timeout_s)
   else:
       # Use select for Unix
       import select
       # ... existing code ...
   ```
2. 或者使用 `subprocess.communicate()` 配合 `timeout` 参数（更简单但功能受限）
3. 添加 `@pytest.mark.skipif(sys.platform == 'win32', reason='...')` 标记（临时方案）

**影响范围：** Windows 平台的 CI/CD 测试","1. 在 Windows 环境执行 `pytest tests/test_server_jsonrpc_smoke_without_sumo_home.py -v`，验证测试通过
2. 在 Linux 环境执行相同测试，确保无回归
3. 验证测试超时机制正常工作（mock 慢响应）
4. 执行完整测试套件 `pytest tests/ -v`，确保所有测试通过
5. 在 CI 配置中添加 Windows 测试（如 GitHub Actions 的 `runs-on: windows-latest`）","1. 确认 threading 方案不会导致测试僵死（daemon=True 正确设置）
2. 验证 queue.get(timeout) 的异常处理正确
3. 考虑使用第三方库如 `pytest-timeout` 简化实现
4. 检查是否有其他测试文件存在类似问题（全局搜索 `selectors`）
5. 更新测试文档说明跨平台兼容性",已完成,已完成
P0-4,MCP: 修复调用卡住/undefined（stdio 污染 + random_trips 参数兼容）,"**背景：** GitHub Issue #1 / 用户反馈：在宿主侧调用 `manage_demand(random_trips)` 或 `run_workflow(sim_gen_eval)` 时，界面显示一直处理中，响应区域为 `undefined`，但磁盘上已生成部分输出文件。

**根因：**
1. MCP 使用 stdio 传输 JSON-RPC；任何非 JSON 文本写入 stdout 都会污染协议流，导致宿主无法解析响应。
2. 用户侧常见参数误用：random_trips 使用 `end` 而非 `end_time`，旧实现会回落到默认 `3600`，导致工具长时间运行，宿主看起来像卡住。

**修复内容：**
1. 确保所有 TraCI 启动的 SUMO 进程 stdout 不会写入 MCP stdout（重定向到 DEVNULL）。
2. `manage_demand(random_trips)` 兼容 `params.end` 作为 `end_time` 别名，并对 `end_time/period` 做类型校验，避免 silent fallback。
3. 文档与测试补齐：API 文档标注别名；增加/完善回归测试覆盖。","1. 执行 `pytest tests/test_api_aliases.py -v` 通过，且覆盖 `end` 别名调用
2. 执行 `pytest tests/test_traci_stdout_redirect.py -v` 通过，验证 `traci.start(..., stdout=DEVNULL)` 被传入
3. `doc/API.md` 与 `src/server.py` 参数契约一致（`end_time` + `end`）","1. 不改变现有 action 名称与返回类型
2. 不在 server stdout 打印任何非 JSON 内容（日志必须走 stderr）
3. 参数兼容必须显式、可预测：冲突时以 `end_time` 优先，错误时给出清晰提示",已完成,已完成
P0-5,测试基础设施: 统一 tests 导入路径并修复 RL 单测不稳定,"**背景：** 当前测试文件中混用 `sys.path.append()` 与 `sys.path.insert(0, ...)`，会导致 `mcp_tools` 等模块有时来自 `src/`，有时来自 `.venv/site-packages/`。在完整测试套件中，由于 import cache 复用，`tests/test_rl.py` 会不稳定地失败（典型报错：`Error: Network file not found at dummy.net.xml`）。

**根因：**
1. `sys.path.append()` 仅追加搜索路径，无法保证优先导入本仓库 `src/` 代码。
2. 单测使用 dummy 文件名但未创建文件，若导入到真实实现则会触发存在性校验失败。

**修复内容：**
1. 新增 `tests/conftest.py`，在测试启动时将 `src/` 路径置顶（并去重），确保全套测试一致导入本仓库代码。
2. 修复 `tests/test_rl.py::test_run_training`：使用 `tmp_path` 创建 dummy `.net.xml/.rou.xml`，或 mock `os.path.exists`，使其与真实实现契约一致。

**影响范围：** 全量测试稳定性、回归可信度","1. 执行 `pytest tests/ -q` 不再出现 `tests/test_rl.py::TestRLTools::test_run_training` 的不稳定失败
2. `tests/test_rl.py` 不依赖外部真实 SUMO 文件/路径（使用 tmp_path 或 mock）
3. `tests/` 下所有测试导入到的 `mcp_tools/__file__` 来自 `src/`（而非 site-packages）","1. `conftest.py` 仅做最小化的 sys.path 置顶，不引入额外 fixture 依赖
2. 不修改被测代码的文件存在性校验逻辑（通过测试侧创建文件/打桩适配）
3. 保持 Windows 兼容（不要写死 POSIX 路径分隔符）",已完成,已完成
P0-6,超时机制: 为所有 subprocess 工具加入自适应超时,"**背景：** `mcp_tools/*` 中封装了 SUMO 二进制/脚本调用（`subprocess.run`）。当前缺少超时控制，一旦底层进程卡死（或输入规模过大），MCP 调用会永久阻塞，表现为宿主侧一直请求中。

**修复内容：**
1. 引入/使用 `src/utils/timeout.py`（智能超时控制器），提供：
   - 静态超时（短操作）
   - 参数自适应超时（randomTrips/仿真等）
2. 在以下模块使用 `subprocess_run_with_timeout()` 替代裸 `subprocess.run()`：
   - `src/mcp_tools/network.py`
   - `src/mcp_tools/route.py`
   - `src/mcp_tools/signal.py`
3. 保持 `capture_output=True`，避免 stdout 污染 MCP stdio。

**影响范围：** 防止工具/工作流卡死造成 MCP 永久阻塞","1. 单测验证每个工具调用都会向 subprocess.run 传入 `timeout` 且 `capture_output=True`
2. `TimeoutExpired` 会被转译为 `TimeoutError` 且错误信息可读
3. 执行 `pytest tests/ -q` 通过（不要求本机有 SUMO）","1. 不引入网络依赖
2. 保持 Windows 兼容（不写死 /dev/null；优先输出到文件或使用平台分支）
3. 不改变现有工具返回值类型（仍为 string）",已完成,已完成
P0-7,RL: 隔离 sumo-rl/SUMO stdout 并加入训练超时,"**背景：** `sumo-rl` 内部启动 SUMO 时可能向 stdout 输出日志，污染 MCP stdio，导致宿主解析失败（表现为 `undefined`）。同时 RL 训练属于长任务，缺少超时/心跳机制时可能无限等待。

**修复内容：**
1. 在 `src/mcp_tools/rl.py::run_rl_training` 中增强 `additional_sumo_cmd`：
   - 将 `--error-log/--log/--message-log` 指向 `out_dir` 下的文件（避免 stdout 输出）
   - 保持跨平台（Windows 使用 `NUL` 或文件；Unix 使用文件）
2. 接入 `utils.timeout.run_with_adaptive_timeout()`（心跳 + 指数退避）为训练过程提供可中断的超时策略：
   - 有心跳则延长
   - 无心跳则判定卡死并返回可诊断错误
3. 补充单测：mock `sumo_rl.SumoEnvironment` 与 `QLAgent`，验证日志参数注入与超时行为可触发。

**影响范围：** RL 工具稳定性与 MCP 输出安全","1. 单测验证 `additional_sumo_cmd` 包含 `--error-log/--log/--message-log`
2. 单测验证无心跳时会触发超时中断并返回可诊断错误
3. 执行 `pytest tests/ -q` 通过（不要求本机有 SUMO）","1. 不修改 sumo-rl 源码（只在 wrapper 层处理）
2. 不向 MCP stdout 输出任何非 JSON 内容（日志必须走 stderr 或文件）
3. 超时策略需可配置并有上限（避免无限扩展）",已完成,已完成
P0-8,MCP: 全局抑制 TraCI stdout（避免 RL 超时后污染 stdio）,"**背景：** 当前 RL 训练超时使用后台线程（`utils.timeout.run_with_adaptive_timeout`）。当超时触发时，主线程会返回错误响应，但后台线程可能仍继续运行并再次调用 `traci.start()`。如果此时 `traci.start()` 的 stdout 未被抑制，可能再次污染 MCP 的 JSON-RPC stdio，导致宿主端表现为 `undefined`/请求一直处理中。

**修复内容：**
1. 新增 `src/utils/traci.py`：提供 `ensure_traci_start_stdout_suppressed()`，将 `traci.start` 包装为默认 `stdout=subprocess.DEVNULL`（不覆盖显式传入的 stdout），并保证幂等。
2. 在 `src/server.py` 启动阶段调用一次，确保整个进程内所有 `traci.start()`（包括 sumo-rl 内部）默认不向 stdout 输出。
3. `src/mcp_tools/rl.py` 调用该 ensure，移除/避免“临时 patch 后还原”导致的窗口期。

**影响范围：** 防止任意 TraCI/SUMO 输出破坏 MCP stdio 协议","1. 单测验证 `ensure_traci_start_stdout_suppressed()` 会为未显式提供 stdout 的 `traci.start()` 注入 `subprocess.DEVNULL` 且不覆盖显式 stdout
2. 单测验证该 patch 幂等（重复调用不会多层包装）
3. 执行 `pytest -q` 通过","1. 不引入 stdout 输出（避免污染 MCP）
2. 兼容 `traci.start` 不支持 stdout 参数的场景（需降级处理）
3. 变更应集中且可回滚（避免在多处散落 monkeypatch 逻辑）",已完成,已完成
P1-6,健壮性: get_sumo_info subprocess 增加超时,"**背景：** `src/server.py::get_sumo_info` 直接调用 `subprocess.run([sumo, --version])`，缺少超时。极端情况下若 SUMO 可执行文件卡死，MCP 调用会永久阻塞。

**修复内容：**
1. 使用 `utils.timeout.subprocess_run_with_timeout()` 或在 `subprocess.run` 上增加合理 timeout（例如 10s-30s）。
2. 保持 `capture_output=True`，避免 stdout 污染 MCP stdio。

**影响范围：** 防止 get_sumo_info 卡死导致 MCP 无响应","1. 单测 mock `subprocess.run` 断言传入 `timeout` 且 `capture_output=True`
2. `TimeoutExpired` 会被转译为可读错误消息
3. 执行 `pytest -q` 通过","1. 不改变成功返回格式
2. 超时时间应足够短（该命令应非常快）
3. 不引入额外依赖",已完成,已完成
P1-5,异常处理: 清理 bare except 并补充诊断信息,"**背景：** 部分模块存在 `except:`（bare except）或过宽的异常捕获，会掩盖真实错误并降低可维护性；部分 traci 调用缺少上下文诊断。

**修复内容：**
1. 将 `except:` 替换为 `except Exception as e:` 并在必要时记录 debug 信息（stderr logger）
2. 对关键 traci 调用增加更清晰的错误消息（包含 SUMO_HOME/二进制定位/关键路径）

**影响范围：** 提升错误可诊断性，避免隐藏异常","1. 执行 `pytest tests/ -q` 通过
2. 新增/更新单测覆盖至少 1 处 bare except 替换后的行为（错误信息可读且不吞异常）","1. 不引入 stdout 输出（避免污染 MCP）
2. 仅在错误路径补充诊断，不改变成功输出格式",已完成,已完成
P0-9,TraCI: 为交互式控制接口增加超时与断开策略,"**背景：** `control_simulation`/`query_simulation_state` 依赖 TraCI socket 调用；当 SUMO 进程异常退出、网络中断或 TraCI 卡死时，这些调用可能永久阻塞，表现为 MCP 请求一直处理中。

**根因（第一性原理）：**
- MCP 是请求/响应模型：任何工具调用都必须可在有限时间内返回（成功或失败）。
- TraCI 调用本质是阻塞式 I/O：若底层 socket recv/send 卡住而无超时，应用层也会卡住。

**修复内容：**
1. 为 `utils/connection.py` 的关键 TraCI 操作引入“软超时”包装（线程 join 超时）：`connect/init/simulationStep/close`。
2. 超时触发时，尝试执行 `traci.close()` 并将连接状态标记为断开，避免后续调用持续挂起。
3. 追加单测：mock 让 TraCI 调用永久阻塞（sleep），断言 API 在超时内返回可读错误且连接状态被 reset。

**影响范围：** 防止交互式工具永久阻塞","1. 单测验证 `control_simulation(step)` 在模拟阻塞时会在预期超时内返回包含 `TimeoutError` 的可读消息
2. 单测验证超时后 `connection_manager.is_connected()==False`
3. 执行 `pytest -q` 通过","1. 不引入 stdout 输出
2. 超时为可配置常量（默认建议 5-10s）
3. 不改变正常路径下的返回格式",已完成,已完成
P0-10,RL: 超时后训练应可终止并释放资源,"**背景：** 当前 RL 超时是“返回错误响应”，但后台线程仍可能继续运行（CPU/内存/文件句柄占用），影响后续请求与系统稳定性。

**第一性原理：**
- “超时”不仅要返回给用户，更应当尽可能停止实际工作（或让其可控退出），否则只是把问题转移到后台。

**修复内容：**
1. 在 `mcp_tools/rl.py` 的训练循环中引入取消标记（`threading.Event`），并在每次循环/关键点检查，允许优雅退出并调用 `env.close()`。
2. 在 `utils/timeout.run_with_adaptive_timeout` 超时判定路径上触发取消回调（若 func 支持），以便训练侧收到 cancel 信号。
3. 单测：mock env.step() 长时间阻塞/无心跳，断言返回超时后会触发 cancel 逻辑（例如记录 flag），并且 close 被调用（可通过 DummyEnv 断言）。

**影响范围：** 防止 RL 超时后后台继续跑","1. 单测验证超时返回后 cancel 回调被触发
2. 单测验证在可中断场景下 `env.close()` 被调用
3. 执行 `pytest -q` 通过","1. 不修改 sumo-rl 源码
2. 不向 stdout 输出
3. 取消机制应兼容 Windows（spawn/thread 行为差异）",已完成,已完成
P0-11,Simulation: 为 run_simple_simulation 增加自适应超时与超时回收,"**背景：** `run_workflow(sim_gen_eval)` 与 `signal_opt_workflow` 都依赖 `mcp_tools.simulation.run_simple_simulation`。当前实现以 TraCI 循环推进 `simulationStep()`，当路网规模大/车辆多/steps 高或 SUMO 异常时，可能出现长期阻塞，表现为 MCP 请求一直处理中（即使最终会生成部分输出文件）。

**根因（第一性原理）：**
- MCP 工具调用必须“有界”：不能无限等待底层仿真。
- TraCI 是阻塞 I/O；缺少超时会把不确定性暴露给客户端。

**修复内容：**
1. 在 `src/mcp_tools/simulation.py::run_simple_simulation` 外围增加自适应超时（基于 `utils.timeout.calculate_adaptive_timeout('simulation', {'steps': steps})`），保证最坏情况下可返回。
2. 超时触发时执行 best-effort 清理：调用 `traci.close()`，并返回可诊断错误信息（不向 stdout 输出）。
3. 新增单测：mock `traci.simulationStep` 阻塞，断言函数在超时内返回包含 `TimeoutError` 的字符串且尝试 close（可通过 mock 计数断言）。

**影响范围：** 防止工作流因仿真步骤阻塞而卡死","1. 单测验证阻塞时 `run_simple_simulation` 返回包含 `TimeoutError` 的可读错误且不会挂死
2. 单测验证超时路径会调用 `traci.close()`（best-effort）
3. 执行 `pytest -q` 通过","1. 不引入 stdout 输出
2. 超时阈值必须通过 `utils.timeout` 统一计算/配置
3. 不改变成功路径返回格式",未开始,等待确认
P1-7,RL: 补齐 manage_rl_task(train_custom) 验收单测,"**背景：** `P1-3` 已实现参数同义字段与 scenario 解析，但缺少验收级单测，存在“实现漂移/回归不自知”的风险。

**修复内容：**
1. 新增单测覆盖 `server.manage_rl_task(train_custom)`：
   - `episodes|num_episodes`、`steps|steps_per_episode`、`out_dir|output_dir` 同义字段解析一致（patch `server.run_rl_training` 断言入参）。
2. 新增单测覆盖 `scenario`/`scenario_name` 解析：
   - mock `mcp_tools.rl.find_sumo_rl_scenario_files` 返回固定路径，断言 server 透传并进入训练 wrapper。

**影响范围：** 参数契约的可回归性","1. `pytest -q` 下新增单测通过
2. 单测不依赖真实 SUMO/sumo-rl 安装（全部 mock）","1. 单测必须验证“入参一致性”而非仅返回字符串
2. 不引入网络依赖",未开始,等待确认
P1-8,超时机制: 补齐 tlsCycleAdaptation/tlsCoordinator 的 TIMEOUT_CONFIGS 配置,"**背景：** 当前 `mcp_tools/signal.py` 使用 `subprocess_run_with_timeout(operation='tlsCycleAdaptation'|'tlsCoordinator')`，但 `TIMEOUT_CONFIGS` 未显式定义这两个 operation，导致回退到默认超时（base=60,max=3600）。这会让短工具拥有过长的最大等待窗口，也不利于统一的超时策略审计。

**修复内容：**
1. 在 `src/utils/timeout.py::TIMEOUT_CONFIGS` 新增：
   - `tlsCycleAdaptation`: base_timeout 合理值（建议 120s），max_timeout（建议 600s）
   - `tlsCoordinator`: base_timeout 合理值（建议 120s），max_timeout（建议 600s）
2. 新增单测：验证 `calculate_adaptive_timeout('tlsCycleAdaptation')` 与 `calculate_adaptive_timeout('tlsCoordinator')` 返回值符合配置（至少不再走默认）。

**影响范围：** 统一超时策略与可审计性","1. 单测覆盖上述两个 operation 的 timeout 计算
2. `pytest -q` 通过","1. 不改变现有工具返回类型/格式
2. 不引入额外依赖",未开始,等待确认
P2-4,MCP: 限制工具返回的 stdout/stderr 大小（避免超大响应）,"**背景：** 多个工具直接拼接返回 `stdout/stderr`。当底层输出很大时，会导致 MCP 响应体巨大、宿主 UI 卡顿或传输失败。

**修复内容：**
1. 新增 `utils/output.py`：提供 `truncate_text(text, max_chars)`，默认保留尾部并标记被截断。
2. 在 `mcp_tools/network.py|route.py|signal.py` 等返回中使用截断后的 stdout/stderr（例如 8000 字符）。
3. 单测：构造超长 stdout，断言输出被截断且包含提示，不改变返回类型（仍为 string）。

**影响范围：** 提升大输出场景稳定性","1. 单测覆盖截断逻辑与工具返回拼接
2. `pytest -q` 通过","1. 不改变正常短输出格式
2. 截断阈值集中配置",未开始,等待确认
P3-3,路网生成(Spider): 实现 spider 专属参数映射,"**背景：** `P3-2` 当前仅能通过 options 注入 `--spider`，但未将 `arms/ring_radius/radial_distance/...` 等参数映射到 `netgenerate` 命令，导致用户传参无效。

**修复内容：**
1. 在 `server.manage_network(generate)` 明确 Grid/Spider 互斥：`spider=true` 时忽略 `grid/grid_number`。
2. 将 spider 参数（如 `arms`）映射到 `netgenerate` 的对应 CLI（与 `netgenerate --help` 对齐）。
3. 进行类型校验（例如 arms 必须为正整数）。

**影响范围：** Spider 网络生成可用性","1. 单测 mock `subprocess.run`，断言 spider 参数会出现在命令行（至少包含 `--spider` 与 `--spider.arms <n>`）
2. 参数非法时返回可读错误
3. `pytest -q` 通过","1. 参数名必须与 SUMO CLI 对齐
2. 不破坏现有 grid 默认行为",未开始,等待确认
P3-4,路网生成(Spider): 补齐验收单测（spider 不含 grid）,"**背景：** `P3-2/P3-3` 需要验收级单测，避免后续回归再出现“silent fallback 到 grid”。

**修复内容：**
1. 新增单测：当 `spider=true` 时断言命令行包含 `--spider` 且不包含 `--grid`。
2. 新增单测：当 `grid=true`（默认）时仍包含 `--grid` 且不包含 `--spider`。

**影响范围：** Spider/Grid 互斥逻辑的可回归性","1. `pytest -q` 通过
2. 单测不依赖真实 SUMO（二进制与 subprocess 全 mock）","1. 断言必须覆盖“互斥”而非仅某个 flag 存在",未开始,等待确认
