import os
import sys
import subprocess
import json
import shutil
import pytest

# This module runs real SUMO simulations/tools. Skip in environments without SUMO.
HAS_SUMO = bool(os.environ.get("SUMO_HOME")) or shutil.which("sumo") is not None
pytestmark = pytest.mark.skipif(
    not HAS_SUMO,
    reason="Requires SUMO installed (set SUMO_HOME or add `sumo` to PATH).",
)

# Add src to path
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "src"))

def test_signal_opt_workflow():
    # Setup paths
    base_dir = os.path.dirname(__file__)
    fixtures_dir = os.path.join(base_dir, "fixtures", "simple_sim")
    output_dir = os.path.join(base_dir, "output_signal_opt")
    
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
        
    # We need a net and route file. We can reuse the ones generated by sim_gen or simple_sim fixtures.
    # Let's generate them quickly using netgenerate if they don't exist.
    if not os.path.exists(fixtures_dir):
        os.makedirs(fixtures_dir)
        
    net_file = os.path.join(fixtures_dir, "hello.net.xml")
    trips_file = os.path.join(fixtures_dir, "hello.trips.xml")
    route_file = os.path.join(fixtures_dir, "hello.rou.xml")
    
    # Ensure fixtures exist (re-run generation commands if needed)
    # Ideally we should use the tools we just implemented, but we are testing the server wrapper.
    # Let's use the server to run the workflow which takes existing files.
    
    # For this test, let's assume fixtures exist or use the ones from previous turn.
    # If not, we might fail. Let's make sure they exist.
    # We can use our new tools code directly to generate them for testing.
    from mcp_tools.network import netgenerate
    from mcp_tools.route import random_trips, duarouter
    
    netgenerate(net_file, grid=True, grid_number=3, options=["--tls.guess"])
    random_trips(net_file, trips_file, end_time=50)
    duarouter(net_file, trips_file, route_file)
    
    # Now run the workflow via server script (integration test)
    server_path = os.path.join(base_dir, "..", "src", "server.py")
    python_exe = sys.executable # Use current python
    
    process = subprocess.Popen(
        [python_exe, server_path],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=0
    )
    
    # Initialize
    process.stdin.write(json.dumps({"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": {}}) + "\n")
    process.stdin.flush()
    process.stdout.readline()
    
    process.stdin.write(json.dumps({"jsonrpc": "2.0", "method": "notifications/initialized"}) + "\n")
    process.stdin.flush()
    
    # Call Workflow
    req = {
        "jsonrpc": "2.0",
        "id": 2,
        "method": "tools/call",
        "params": {
            "name": "run_workflow",
            "arguments": {
                "workflow_name": "signal_opt",
                "params": {
                    "net_file": net_file,
                    "route_file": route_file,
                    "output_dir": output_dir,
                    "steps": 50,
                    "use_coordinator": False 
                }
            }
        }
    }
    process.stdin.write(json.dumps(req) + "\n")
    process.stdin.flush()
    
    line = process.stdout.readline()
    response = json.loads(line)
    
    if "error" in response:
        print("Error:", response["error"])
        assert False
        
    content = response["result"]["content"][0]["text"]
    print("Workflow Output:\n", content)
    
    assert "Signal Optimization Workflow Completed" in content
    assert "Baseline Results" in content
    assert "Optimized Results" in content
    
    process.terminate()

if __name__ == "__main__":
    test_signal_opt_workflow()
